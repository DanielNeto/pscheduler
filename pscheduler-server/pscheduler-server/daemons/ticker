#!/usr/bin/python
#
# Operate all on-boot and periodic functions in the database.
#

import daemon
import datetime
import errno
import optparse
import pscheduler
import psycopg2
import psycopg2.extensions
import sys
import time

#
# Gargle the arguments
#

opt_parser = optparse.OptionParser()

# Daemon-related options

opt_parser.add_option("--daemon",
                      help="Daemonize",
                      action="store_true",
                      dest="daemon", default=False)
opt_parser.add_option("--pid-file",
                      help="Location of PID file",
                      action="store", type="string", dest="pidfile",
                      default=None)

# Program options

opt_parser.add_option("-d", "--dsn",
                      help="Database connection string, prefix with @ to read from file",
                      action="store", type="string", dest="dsn",
                      default="")
opt_parser.add_option("-r", "--retry",
                      help="No-rows-returned retry interval (ISO8601)",
                      action="store", type="string", dest="retry",
                      default="PT15S")
opt_parser.add_option("--vacuum",
                      help="Database vacuum/analyze interval (ISO8601)",
                      action="store", type="string", dest="vacuum",
                      default="P1D")
opt_parser.add_option("-v", "--verbose", action="store_true", dest="verbose")
opt_parser.add_option("--debug", action="store_true", dest="debug")


(options, args) = opt_parser.parse_args()

retry = pscheduler.iso8601_as_timedelta(options.retry)
if retry is None:
    opt_parser.error('Invalid retry interval "' + options.retry + '"')
if pscheduler.timedelta_as_seconds(retry) == 0:
    opt_parser.error("Retryinterval must be calculable as seconds.")


dsn = options.dsn

try:
    vacuum_interval = pscheduler.iso8601_as_timedelta(options.vacuum)
except ValueError:
    opt_parser.error("Invalid vacuum interval; must be ISO8601")


#
# Main Program
#

def main_program():

    log = pscheduler.Log(verbose=options.verbose, debug=options.debug)

    # TODO: Bulletproof the SQL queries

    db = pscheduler.pg_connection(dsn)
    cursor = db.cursor()

    log.debug("Booting")
    cursor.execute("SELECT cold_boot()")
    log.debug("Booted")


    # Assume the last vacuum was a very long time ago.
    last_vacuum = pscheduler.time_epoch()

    while True:

        # This has to be done outside the database.
        if pscheduler.time_now() - last_vacuum > vacuum_interval:
            log.debug("Vacuuming the database")
            try:
                cursor.execute("VACUUM ANALYZE")
            except Exception as ex:
                log.error("Failed to vacuum the database: %s" % str(ex))
            last_vacuum = pscheduler.time_now()
        else:
            log.debug("Next vacuuming in %s",
                      (vacuum_interval - (pscheduler.time_now() - last_vacuum)))


        log.debug("Tick")
        cursor.execute("SELECT ticker()")

        if cursor.rowcount == 0:
            log.debug("Got no rows back from the database, retrying in"
                      + str(options.retry) + "\n")
            sleep(pscheduler.timedelta_as_seconds(options.retry))
            continue

        sleep_time = cursor.fetchone()[0]
        seconds = pscheduler.timedelta_as_seconds(sleep_time)
        log.debug("Next check in %d seconds", seconds)
        time.sleep(seconds)

    # Not that this will ever be reached...
    pg.close()


if options.daemon:
    pidfile = pscheduler.PidFile(options.pidfile)
    with daemon.DaemonContext(pidfile=pidfile):
        pscheduler.safe_run(lambda: main_program())
else:
    pscheduler.safe_run(lambda: main_program())
