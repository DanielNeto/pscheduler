#!/usr/bin/python
#
# Execute runs of tasks and put the results into the database.
#

import datetime
import detach
import json
import optparse
import os
import pscheduler
import psycopg2
import psycopg2.extensions
import select
import signal
import subprocess
import sys
import time


# Gargle the arguments

opt_parser = optparse.OptionParser()
opt_parser.add_option("-c", "--channel",
                      help="Schedule notification channel",
                      action="store", type="string", dest="channel",
                      default="run_change")
# TODO: Do we want pscheduler as the default here?
opt_parser.add_option("-d", "--dsn",
                      help="Database connection string",
                      action="store", type="string", dest="dsn",
                      default="dbname=pscheduler")
opt_parser.add_option("-r", "--refresh",
                      help="Forced refresh interval (ISO8601)",
                      action="store", type="string", dest="refresh",
                      default="PT5M")
opt_parser.add_option("-v", "--verbose", action="store_true", dest="verbose")

(options, args) = opt_parser.parse_args()

refresh = pscheduler.iso8601_as_timedelta(options.refresh)
if refresh is None:
    opt_parser.error('Invalid refresh interval "' + options.refresh + '"')
if pscheduler.timedelta_as_seconds(refresh) == 0:
    opt_parser.error("Refresh interval must be calculable as seconds.")


dsn = options.dsn


#
# Utilities
#

is_verbose = options.verbose
def verbose(first, *args):
    if not is_verbose:
        return
    sys.stdout.write(first)
    for arg in args:
        sys.stdout.write(' ')
        sys.stdout.write(str(arg))
    sys.stdout.write('\n')



#
# Runs and things we do with them
#
class Run:
    """What is known or can be inferred from a run pulled from the database"""


    def __init__(self, id, start_in, tool, participant, partdata, test, start, duration):
        self.id = id
        self.start_in = start_in
        self.tool = tool
        self.participant = participant,
        self.test = test,
        self.start = start,
        self.duration = duration,

        self.tool_input = {
            'schema': 1,
            'schedule': {
                'start': pscheduler.datetime_as_iso8601(start),
                'duration': pscheduler.timedelta_as_iso8601(duration)
                },
            'test': test,
            'participant': participant,
            'participant-data': partdata
            }


    def run(self):
        # TODO: Log this?
        verbose("TEST", self.id, "WITH", self.tool, ":  ", json.dumps(self.tool_input))
        with detach.Detach(close_fds=True, stdout=sys.stdout, stderr=sys.stderr) as detacher:

            if detacher.pid:
                self.pid = detacher.pid
                return

            try:
                db = pscheduler.pg_connection(dsn, False)
                cursor = db.cursor()
                # TODO: Running a process (with timeout) should be its own module.
                process = subprocess.Popen(
                    [ "pscheduler", "internal", "invoke", "tool", self.tool, "run" ],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE )

                stdout, stderr = process.communicate(json.dumps(self.tool_input))
                returncode = process.returncode

                if len(stdout) == 0:
                    stdout = None

                if len(stderr) == 0:
                    stderr = None

                # TODO: Remove this.
                if returncode == 0:
                    verbose("TEST SUCCESS: ", stdout)
                else:
                    verbose("TEST FAILED ", returncode, ": ", stderr)

                cursor.execute("""
                               UPDATE run
                               SET
                                   status = %s,
                                   result = %s,
                                   errors = %s
                               WHERE id = %s
                               """,
                               [returncode, stdout, stderr, self.id])
                db.commit()


                # The lead participant takes care of gathering and merging the finished results.

                if self.participant == 0:

                    # TODO: Should probably wait until the end of the
                    # scheduled run has passed.

                                       

                # TODO: Combine the results into a single result

                # TODO: Store the single result and call the run finished.

                # TODO: Schedule additional runs up to the horizon if merited

                cursor.close()
                db.close()

            except Exception as exception:
                # TODO: Log this?
                print "EXCEPTION: ", str(exception)





#
# Main Program
#

pg = pscheduler.pg_connection(dsn)
cursor = pg.cursor()
cursor.execute("LISTEN " + options.channel)

while True:

    cursor.execute("SELECT run, start_in, tool, participant, part_data_full, test, start, duration \
                    FROM schedule_upcoming \
                    WHERE start_in = (SELECT min(start_in) FROM schedule_upcoming)");

    if cursor.rowcount:
        # TODO: There must be a nicer way to take this array slice as args.
        runs = [ Run(row[0], row[1], row[2], row[3], row[4], row[5], row[6], row[7]) for row in cursor.fetchall() ]
        wait_time = runs[0].start_in
    else:
        runs = []
        wait_time = refresh

    verbose("Next run or check in", wait_time)
    if not pscheduler.timedelta_is_zero(wait_time):
        # Wait for a notification or the wait time to elapse.  Eat all
        # notifications as a group; we only care that we were notified.
        if select.select([pg],[],[], pscheduler.timedelta_as_seconds(wait_time)) != ([],[],[]):
            # Notified
            pg.poll()
            del pg.notifies[:]
            verbose("Schedule change.")
            continue

    for run in runs:
        verbose("Running", run.id)
        # Do this here and not in the forked process to ensure we
        # don't get this row in the next iteration.
        cursor.execute("UPDATE run SET state = run_state_running() WHERE id = %s", [ run.id ])
        run.run()



# Not that this will ever be reached...
pg.close()
