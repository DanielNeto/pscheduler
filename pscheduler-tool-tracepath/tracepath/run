#!/usr/bin/python
#
# Run a test.  Just the test spec is provided on stdin.
#


import icmperror
import pscheduler
import re

input = pscheduler.json_load(exit_on_error=True);

# TODO: Validate the input
# TODO: Verify can-run

participant = input['participant']

if participant != 0:
    pscheduler.fail("Invalid participant.")

spec = input['test']['spec']



#
# Figure out how to invoke the program
#

argv = []

tracepath = 'tracepath'
try:
    ipversion = spec['ip-version']
    if ipversion == 6:
        tracepath = 'tracepath6'
except KeyError:
    pass
argv.append(tracepath)



try:
    hostnames = spec['hostnames']
    if not hostnames:
        argv.append('-n')
except KeyError:
    hostnames = False

try:
    length = spec['length']
    argv.append('-l')
    argv.append(str(length))
except KeyError:
    pass


# At some point, tracepath changed the way its command line works to
# be more compatible with traceroute's options.  Since it doesn't
# provide a way to determine which scheme is in use, the only way to
# figure it out is to run the program, expect a return code of 255 and
# figure out which style of invocation is expects.  That's quality
# with a capital "K."
#
# Earlier:  tracepath [-n] [-l <len>]                <destination>[/<port>]
# Later:    tracepath [-n] [-l <len>] [-b] [-p port] <destination>

# TODO: Investigate whether we care about the -b switch.

status, stdout, stderr = pscheduler.run_program( [tracepath], short=True)
if status != 255 or '<destination>' not in stderr:
    pscheduler.fail(
        "Unable to determine which version of tracepath is installed.")

if '[-p port]' in stderr:
    traceroute_compatible = True
else:
    traceroute_compatible = False


dest = spec['dest']

try:
    port = str(spec['dest-port'])
    if traceroute_compatible:
        argv.append('-p')
        argv.append(port)
    else:
        dest += '/' + str(port)
except KeyError:
    pass

argv.append(dest)


#
# Run the test
#


status, stdout, stderr = pscheduler.run_program( argv, timeout = 62 )

if status != 0:
    pscheduler.fail(stderr)



#
# Dissect the results
#

try:
    hostnames = spec['hostnames']
except KeyError:
    hostnames = True

try:
    as_ = spec['as']
except KeyError:
    as_ = False

hops = []
last_hop = 0

for line in stdout.split('\n'):
    line = re.sub('\s+', ' ', line).strip()
    matches = re.match('^(\d*):\s+(.*)$', line)
    if matches is None:
        continue
    this_hop =  int(matches.group(1))

    # Repeats of a hop replace earlier ones
    if this_hop == len(hops):
        hops.pop()

    elements = matches.group(2).split()

    hop = {}

    # No reply means no results

    if elements[0] == 'no' and elements[1] == 'reply':
        hops.append(hop)
        continue

    # Hostname and IP

    if hostnames:
        hostname = elements.pop(0)
        ip = elements.pop(0)[1:-1]
        hop['ip'] = ip
        if hostname != ip:
            hop['hostname'] = hostname
    else:
        hop['ip'] = elements.pop(0)

    # RTT (ms)

    rtt = float(elements.pop(0)[:-2]) / 1000.0
    hop['rtt'] = 'PT%fS' % rtt

    # Drop asymmetry if there is any.

    if len(elements) > 0 and elements[0] == 'asymm':
        elements.pop(0)
        elements.pop(0)

    # Anything left will either be 'reached' or an error

    if len(elements) > 0:
        reached_err = elements.pop(0)
        if reached_err[0] == '!':
            hop['error'] = icmperror.translate(reached_err)


    hops.append(hop)


# Spit out the results

pscheduler.succeed_json( {
        'succeeded': True,
        'hops': hops
        } )
