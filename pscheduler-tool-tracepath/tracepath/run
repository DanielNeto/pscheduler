#!/usr/bin/python
#
# Run a test.  Just the test spec is provided on stdin.
#


import icmperror
import pscheduler
import re

input = pscheduler.json_load(exit_on_error=True);

log = pscheduler.Log(prefix='tracepath', quiet=True)

# TODO: Validate the input
# TODO: Verify can-run

participant = input['participant']

log.debug("Participant %d", participant)
if participant != 0:
    pscheduler.succeed_json( {
            'succeeded': False,
            'diags': None,
            'error': "Invalid participant %d" % participant,
            'result': None
            } )

spec = input['test']['spec']




#
# Figure out how to invoke the program
#

argv = []

tracepath = 'tracepath'
try:
    ipversion = spec['ip-version']
    if ipversion == 6:
        tracepath = 'tracepath6'
except KeyError:
    pass
argv.append(tracepath)

# Always run without resolving IPs; we'll do that in parallel after it finishes.
argv.append('-n')


try:
    length = spec['length']
    argv.append('-l')
    argv.append(str(length))
except KeyError:
    pass


# At some point, tracepath changed the way its command line works to
# be more compatible with traceroute's options.  Since it doesn't
# provide a way to determine which scheme is in use, the only way to
# figure it out is to run the program, expect a return code of 255 and
# figure out which style of invocation is expects.  That's quality
# with a capital "K."
#
# Earlier:  tracepath [-n] [-l <len>]                <destination>[/<port>]
# Later:    tracepath [-n] [-l <len>] [-b] [-p port] <destination>

# TODO: Investigate whether we care about the -b switch.

status, stdout, stderr = pscheduler.run_program( [tracepath], short=True)
if status != 255 or '<destination>' not in stderr:
    pscheduler.succeed_json( {
            'succeeded': False,
            'diags': None,
            'error': "Unable to determine version of tracepath installed.",
            'result': None
            } )


if '[-p port]' in stderr:
    traceroute_compatible = True
else:
    traceroute_compatible = False


dest = spec['dest']

try:
    port = str(spec['dest-port'])
    if traceroute_compatible:
        argv.append('-p')
        argv.append(port)
    else:
        dest += '/' + str(port)
except KeyError:
    pass

argv.append(dest)


#
# Run the test
#


status, stdout, stderr = pscheduler.run_program( argv, timeout = 62 )

if status != 0:
    pscheduler.succeed_json( {
            'succeeded': False,
            'diags': None,
            'error': stderr,
            'result': None
            } )



#
# Dissect the results
#

try:
    as_ = spec['as']
except KeyError:
    as_ = False

traced_hops = []
ips = []
last_hop = 0

for line in stdout.split('\n'):
    line = re.sub('\s+', ' ', line).strip()
    matches = re.match('^(\d*):\s+(.*)$', line)
    if matches is None:
        continue
    this_hop =  int(matches.group(1))

    log.debug("LINE %s", line)

    # Repeats of a hop replace earlier ones
    if this_hop == len(traced_hops):
        traced_hops.pop()

    elements = matches.group(2).split()

    hop = {}

    # No reply means no results

    if elements[0] == 'no' and elements[1] == 'reply':
        traced_hops.append(hop)
        continue

    # IP.  We forced tracepath to behave this way.
    ip = elements.pop(0)
    hop['ip'] = ip
    ips.append(ip)
    log.debug("  IP %s", ip)

    # RTT (ms)

    rtt = float(elements.pop(0)[:-2]) / 1000.0
    hop['rtt'] = 'PT%fS' % rtt

    # TODO: Extract PMTU if present.  Need to find out if this is
    # produced before or after asymm.

    # Drop asymmetry if there is any.

    if len(elements) > 0 and elements[0] == 'asymm':
        elements.pop(0)
        elements.pop(0)

    # Anything left will either be 'reached' or an error

    if len(elements) > 0:
        reached_err = elements.pop(0)
        if reached_err[0] == '!':
            hop['error'] = icmperror.translate(reached_err)

    traced_hops.append(hop)


# If we're doing hostnames, bulk-resolve them.

try:
    hostnames = spec['hostnames']
except KeyError:
    hostnames = True

if hostnames and len(ips) > 0:
    log.debug("Reverse-resolving IPs: %s", str(ips))
    revmap = pscheduler.dns_bulk_resolve(ips, reverse=True, threads=len(traced_hops))
    for hop in traced_hops:
        try:
            ip = hop['ip']
            if ip in revmap:
                hop.update({ 'hostname': revmap[ip] })
        except KeyError:
            # No IP is fine.
            pass


# Figure out ASes if we're doing that

try:
    do_ases = spec['as']
except KeyError:
    do_ases = True

if do_ases:
    ases = pscheduler.as_bulk_resolve(ips, threads=len(ips))
    for index, hop in enumerate(traced_hops):
        try:
            hop_as = ases[hop['ip']]
            if hop_as is None:
                continue

            (asn, owner) = hop_as
            if asn is None:
                continue

            result = { 'number': asn }
            if owner is not None:
                result['owner'] = owner
            traced_hops[index]['as'] = result
        except KeyError:
            pass



# Spit out the results

pscheduler.succeed_json( {
        'succeeded': True,
        'diags': stdout,
        'error': stderr,
        'result': {
            'hops': traced_hops
            }
        } )
