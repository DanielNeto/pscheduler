#!/usr/bin/python
#
# This program is a test jig that does a one-shot run of a test.  The
# test being performed can be changed by altering the contents of the
# 'task_json_text' variable declared below with suitable JSON.  See
# the 'test-*' PDFs in the documentation directory for details on
# format.
#
# A number of the things being done here will be migrated into the
# REST API code
#
#
# THIS PROGRAM IS NOT INTENDED FOR USE IN PRODUCTION.
#
#

import datetime
import json
import pscheduler
import requests
import socket
import sys
import time
import urlparse

from dateutil.tz import tzlocal

log = pscheduler.Log(verbose=True)


# Full task, test included.

task_json_text = """
{
    "schema": 1,

    "schedule": {
        "#start": "PT10S",
        "#slip": "PT15S",
        "#repeat": "PT30S",
        "#max-runs": 10
    },

    "test": {
        "type": "simplestream",
        "spec": {
            "schema": 1,
            "receiver": "dev8",
            "dawdle": "PT1S",
            "#test-material": "Madam, in Eden, I'm Adam.",
            "timeout": "PT3S"
        }
    },

    "#test": {
        "type": "trace",
        "spec": {
            "schema": 1,
            "dest": "192.168.1.1"
        }
    },

    "#test": {
        "type": "idle",
        "spec": {
            "schema": 1,
            "duration": "PT5S",
            "parting-comment": "Adios!"
        }
    }
}
"""

# What host to ask for assistance, None for localhost
#helper = 'dev8'
helper = None


# -----------------------------------------------------------------------------
#      CODE BEYOND THIS POINT CONTAINS NO USER-SERVICEABLE PARTS
# -----------------------------------------------------------------------------


def print_partial(message):
    sys.stdout.write(message)
    sys.stdout.flush()



task_json = pscheduler.json_load(task_json_text)

test_type = task_json['test']['type']

#
# Validate the helper
#

print_partial("Contacting the helper...")

status, text =  pscheduler.url_get( pscheduler.api_url(helper, '/hostname'),
                                    throw=False )
if status != 200:
    print " Failed"
    pscheduler.fail("Can't talk to the pScheduler server: " + text)
print " ", text


# TODO: Use the helper to format the task spec

#
# Determine the lead participant
#

url = pscheduler.api_url(helper, '/tests/%s/lead' % task_json['test']['type'])

try:
    status, lead = pscheduler.url_get( url, params={
            'spec': pscheduler.json_dump(task_json['test']['spec'])
            } )
except Exception as ex:
    log.exception()
    pscheduler.fail("Unable to determine the lead participant: " + str(ex))

print "Lead participant is", lead


#
# Give the task to the lead for scheduling.
#

try:
    status, task_url = pscheduler.url_post( pscheduler.api_url(lead, '/tasks'),
                                            data=task_json_text,
                                            throw=False)
except Exception as ex:
    pscheduler.fail("Unable to post task: " + str(ex))

if status != 200:
    pscheduler.fail("Unable to post task: " + task_url)

log.debug("Task URL is %s", task_url)


#
# Get the first future run.
#

tries = 40

runs_url = task_url + '/runs'
log.debug("Runs are at %s", runs_url)

print_partial("Fetching run...")
while tries > 0:
    tries -= 1
    # TODO: Get the whole thing once the API can expand the results.
    status, runs = pscheduler.url_get(
        runs_url,
        params={ 'limit': 1 }, throw=False )

    log.debug("Fetch status %d: %s", status, runs)

    print_partial(".")
    if status == 200 and len(runs) > 0:
            run_url = runs[0]
            print "  ", run_url
            break
    elif status == 200 or status == 404:
        time.sleep(0.25)
        continue
    else:
        print
        pscheduler.fail("Failed to fetch run: " + runs)

if tries == 0:
    pscheduler.fail("Run on server was never populated.")

try:
    status, run_json = pscheduler.url_get(run_url)
except Exception as ex:
    pscheduler.fail("Failed to fetch run: " + str(ex))


#
# Wait for the run to finish
#

wait_time = pscheduler.time_until_seconds(
    pscheduler.iso8601_as_datetime(run_json['end-time'])) 

print_partial("Waiting for the run to finish (%d seconds)..." % (wait_time))
time.sleep(wait_time)
print " Done"


# Temporary wait until we have a better run/result interlock.
# TODO: Remove this

print_partial("Temporary wait for results to be produced.  Badger Mark mercilessly about this...")
time.sleep(5)
print " Done"


#
# Get the final result
#

tries = 40

print_partial("Fetching result...")
while tries > 0:
    tries -= 1
    status, result = pscheduler.url_get(run_url, throw=False)
    print_partial(".")
    if status == 200:
        if result['result-merged'] is not None:
            print " Done"
            break
        time.sleep(0.25)
    else:
        print
        pscheduler.fail("Failed to fetch run: %d: %s" % (status, result))

if tries == 0:
    pscheduler.fail("Couldn't find full result.")

print
print "FINAL FULL RESULT:"
print

if not result['result-merged']['succeeded']:
    print "RUN FAILED.  Full JSON results:"
    print pscheduler.json_dump(result['result-full'], pretty=True)
    pscheduler.fail()

print "JSON:"
print pscheduler.json_dump(result['result-merged'], pretty=True)

print
print "Plain Text:"

# Can add text/html to this list if you really feel like it.
for format in [ 'text/plain' ]:
    print
    print "Formatted %s:" % format

    # TODO: Use the helper server for this when supported.

    returncode, stdout, stderr = pscheduler.run_program(
        [ "pscheduler", "internal", "invoke", "test", test_type, "result-format", format ],
        stdin = pscheduler.json_dump(result['result-merged'])
        )

    if returncode == 0:
        print stdout.strip()
    else:
        pscheduler.fail("Failed to format test: " + stderr)

pscheduler.succeed()
