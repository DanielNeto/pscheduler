#!/usr/bin/python
#
# This program is a test jig that does a one-shot run of a test.  The
# test being performed can be changed by altering the contents of the
# 'test_json_text' variable declared below with suitable JSON.  See
# the 'test-*' PDFs in the documentation directory for details on
# format.
#
# A number of the things being done here will be migrated into the
# REST API code
#
#
# THIS PROGRAM IS NOT INTENDED FOR USE IN PRODUCTION.
#
#

import datetime
import json
import pscheduler
import requests
import socket
import time
import urlparse

from dateutil.tz import tzlocal

test_json_text = """
{
    "type": "simplestream",
    "spec": {
        "schema": 1,
        "receiver": "dev8",
        "dawdle": "PT1S",
        "test-material": "Madam, in Eden, I'm Adam.",
        "timeout": "PT3S"
    }
}
"""


# -----------------------------------------------------------------------------
#      CODE BEYOND THIS POINT CONTAINS NO USER-SERVICEABLE PARTS
# -----------------------------------------------------------------------------


test_json = pscheduler.json_load(test_json_text)
test_type = test_json['type']


def server_url(host, path = None, port = 29285):
    return 'http://' \
        + host \
        + (':' + str(port) if port is not None else '') \
        + ('/' + path if path is not None else '')



print
print "TEST SPECIFICATION:"
print

print "JSON:"
print test_json_text.strip()
print
print "Formatted:"

spec_json = pscheduler.json_dump(test_json['spec'])

returncode, stdout, stderr = pscheduler.run_program(
    [ "pscheduler", "internal", "invoke", "test", test_type, "spec-format" ],
    stdin = spec_json
    )

if returncode == 0:
    print stdout.strip()
else:
    pscheduler.fail("Failed to format test: " + stderr)



#
#
# SPEC PART
#
#


# TODO: All of this needs to be wrapped into a function to post a new
# task.

# Figure out the participant list.  This we do directly since the code
# will become part of the server-side code.

returncode, stdout, stderr = pscheduler.run_program(
    [ "pscheduler", "internal", "invoke", "test", test_type, "participants" ],
    stdin = spec_json
    )

try:
    # TODO: Map to FQDN or leave as localhost?
    participants = [ host if host is not None else socket.getfqdn()
                     for host in pscheduler.json_load(stdout) ]
except Exception as ex:
    pscheduler.fail("Unable to load returned participant list: " + str(ex))
nparticipants = len(participants)


print
print "TOOL SELECTION:"
print

tools = []

# TODO: Get local out of the database.  If we don't and there's only
# one server thread, this will break.
for participant in participants:
    print "Getting tools from", participant
    try:
        r = requests.get(server_url(participant, "tools"),
                         params={ 'test': test_json_text })
        if r.status_code != 200:
            raise Exception("Bad status code")
        tools.append( pscheduler.json_load(str(r.text)) )
    except Exception as ex:
        print "No response from", participant, ex
        break

if len(tools) != nparticipants:
    pscheduler.fail("Didn't get a full set of tool responses")


def pick_tool(lists):
    participants = len(lists)
    """Count and score the number of times each tool appears in a list
    of lists retrieved from servers, then return the name of the tool
    that was preferred or None if there were none in common."""

    # The count is used to determine whether or not a tool is supported
    # by all participants.

    # The score is the sum of each tool's position in each list and is
    # used to determine its overall preference.  Like golf, the tool
    # with the smallest score has the highest preference.

    # TODO: At some point, we'll have to account for minimum schema
    # version supported, too.  (Or will hosts that don't support it just
    # bow out?)

    count = {}
    score = {}

    for tool_list in lists:
        for position in range(len(tool_list)):

            tool = tool_list[position]['name']

            try:
                count[tool] += 1
            except KeyError:
                count[tool] = 1

            try:
                score[tool] += position
            except KeyError:
                score[tool] = position

    # Pick out the tools all lists have in common and their scores.

    common = {}
    for tool in count:
        if count[tool] == participants:
            common[tool] = score[tool]

    # Nothing in common means no thing can be picked.

    if not len(common):
        return None

    # Pick out the common tool with the lowest score.
    ordered = sorted(common.items(), key=lambda value: value[1])
    return ordered[0][0]


tool = pick_tool(tools)
if tool is None:
    pscheduler.fail("Couldn't find a tool in common")
print "Selected tool", tool


#
#
# TASK PART
#
#

print
print "TASK CREATION:"
print

# TODO: The tool needs to be an array.
task = {
    'schema': 1,
    'test': test_json,
    'tool': tool,
    'schedule': {
        'start': '@PT1M',
        'slip': 'PT10S',
        'repeat': 'PT30S',
        'max-runs': 50
        },
    'archives': [
        {
            'name': 'syslog',
            'data': { 'ident': 'log1' }
        },
        {
            'name': 'failer',
            'data': {}
        }
        ]
}


task_data = pscheduler.json_dump(task)

tasks_posted = []

# TODO: Task lead out of the database.  If we don't and there's only
# one server thread, this will break.

# Lead assigns the UUID.
try:
    print "Tasking lead participant on", participants[0]
    r = requests.post(server_url(participants[0], 'tasks'),
                      data=task_data)
    if r.status_code != 200:
        raise Exception("Bad status code: " +  r.text)
    tasks_posted.append(r.text)
    lead_url = r.text
    task_uuid = urlparse.urlparse(lead_url).path.split('/')[-1]
    print "    Task URL is", lead_url
except Exception as ex:
    pscheduler.fail("Error from %s: %s" % (participants[0], ex))


# Other participants get the UUID forced upon them.


for participant in range(1,nparticipants):
    part_name = participants[participant]
    print "Tasking participant %d on %s" % (participant, part_name)
    try:
        r = requests.post(server_url(part_name, 'tasks/' + task_uuid),
                          params={ 'participant': participant },
                          data=task_data)
        if r.status_code != 200:
            raise Exception("Bad status code %d: %s", r.status_code, r.text)
        print "   ", r.text
        tasks_posted.append(r.text)
    except Exception as ex:
        print "Error from %d: %s" % (participant, ex)
        break

# If we failed on any postings, delete the prior ones
if len(tasks_posted) < nparticipants:
    print "Removing already-posted tasks:"
    for url in tasks_posted:
        print "   ", url
        r = requests.delete(url)
    pscheduler.fail("Unable to continue.")


print "STOPPED HERE"
exit(99)



#
#
#
# POST-RUN
#
#
#


print
print "WAITING FOR RUN:"
print

sleeptime = ( schedule_upper - datetime.datetime.now(tzlocal()) ) \
    + datetime.timedelta(seconds=1)

print "Sleeping for", sleeptime
time.sleep(pscheduler.timedelta_as_seconds(sleeptime))


print
print "FINAL FULL RESULT:"
print

r = requests.get(runs_posted[0])
if r.status_code != 200:
    raise Exception("Bad status code: " +  r.text)

merged_full_fetched = pscheduler.json_load(r.text)

print pscheduler.json_dump(merged_full_fetched, pretty=True)

if 'result-merged' in merged_full_fetched:

    print "JSON:"
    print json.dumps(merged_full_fetched['result-merged'], \
                         sort_keys=True, \
                         indent=4, \
                         separators=(',', ': ') \
                         ) + '\n'


    for format in [ 'text/plain', 'text/html' ]:
        print
        print "Formatted %s:" % format

        returncode, stdout, stderr = pscheduler.run_program(
            [ "pscheduler", "internal", "invoke", "test", test_type, "result-format", format ],
            stdin = pscheduler.json_dump(merged_full_fetched['result-merged'])
            )

        if returncode == 0:
            print stdout.strip()
        else:
            pscheduler.fail("Failed to format test: " + stderr)
else:
    print r.text



#
# Clean Up
#
# TODO: Re-enable prints
if False:
    #print "Removing posted tasks:"
    for url in tasks_posted:
        # print "   ", url
        r = requests.delete(url)
        if r.status_code != 200:
            #print "        WARNING: Failed %d: %s" % (r.status_code, r.text)
            pass
