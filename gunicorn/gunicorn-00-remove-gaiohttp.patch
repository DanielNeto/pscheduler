diff -rupN gunicorn-19.4.5-orig/gunicorn/workers/__init__.py gunicorn-19.4.5/gunicorn/workers/__init__.py
--- gunicorn-19.4.5-orig/gunicorn/workers/__init__.py	2015-12-24 03:45:30.000000000 -0500
+++ gunicorn-19.4.5/gunicorn/workers/__init__.py	2016-03-01 12:35:59.000000000 -0500
@@ -16,7 +16,3 @@ SUPPORTED_WORKERS = {
     "gthread": "gunicorn.workers.gthread.ThreadWorker",
 }
 
-
-if sys.version_info >= (3, 3):
-    # gaiohttp worker can be used with Python 3.3+ only.
-    SUPPORTED_WORKERS["gaiohttp"] = "gunicorn.workers.gaiohttp.AiohttpWorker"
diff -rupN gunicorn-19.4.5-orig/gunicorn/workers/_gaiohttp.py gunicorn-19.4.5/gunicorn/workers/_gaiohttp.py
--- gunicorn-19.4.5-orig/gunicorn/workers/_gaiohttp.py	2015-12-24 03:45:30.000000000 -0500
+++ gunicorn-19.4.5/gunicorn/workers/_gaiohttp.py	1969-12-31 19:00:00.000000000 -0500
@@ -1,162 +0,0 @@
-# -*- coding: utf-8 -
-#
-# This file is part of gunicorn released under the MIT license.
-# See the NOTICE for more information.
-
-import asyncio
-import functools
-import logging
-import os
-
-try:
-    import ssl
-except ImportError:
-    ssl = None
-
-import gunicorn.workers.base as base
-
-from aiohttp.wsgi import WSGIServerHttpProtocol
-
-
-class AiohttpWorker(base.Worker):
-
-    def __init__(self, *args, **kw):  # pragma: no cover
-        super().__init__(*args, **kw)
-        cfg = self.cfg
-        if cfg.is_ssl:
-            self.ssl_context = self._create_ssl_context(cfg)
-        else:
-            self.ssl_context = None
-        self.servers = []
-        self.connections = {}
-
-    def init_process(self):
-        # create new event_loop after fork
-        asyncio.get_event_loop().close()
-
-        self.loop = asyncio.new_event_loop()
-        asyncio.set_event_loop(self.loop)
-
-        super().init_process()
-
-    def run(self):
-        self._runner = asyncio.async(self._run(), loop=self.loop)
-
-        try:
-            self.loop.run_until_complete(self._runner)
-        finally:
-            self.loop.close()
-
-    def wrap_protocol(self, proto):
-        proto.connection_made = _wrp(
-            proto, proto.connection_made, self.connections)
-        proto.connection_lost = _wrp(
-            proto, proto.connection_lost, self.connections, False)
-        return proto
-
-    def factory(self, wsgi, addr):
-        # are we in debug level
-        is_debug = self.log.loglevel == logging.DEBUG
-
-        proto = WSGIServerHttpProtocol(
-            wsgi, readpayload=True,
-            loop=self.loop,
-            log=self.log,
-            debug=is_debug,
-            keep_alive=self.cfg.keepalive,
-            access_log=self.log.access_log,
-            access_log_format=self.cfg.access_log_format)
-        return self.wrap_protocol(proto)
-
-    def get_factory(self, sock, addr):
-        return functools.partial(self.factory, self.wsgi, addr)
-
-    @asyncio.coroutine
-    def close(self):
-        try:
-            if hasattr(self.wsgi, 'close'):
-                yield from self.wsgi.close()
-        except:
-            self.log.exception('Process shutdown exception')
-
-    @asyncio.coroutine
-    def _run(self):
-        for sock in self.sockets:
-            factory = self.get_factory(sock.sock, sock.cfg_addr)
-            self.servers.append(
-                (yield from self._create_server(factory, sock)))
-
-        # If our parent changed then we shut down.
-        pid = os.getpid()
-        try:
-            while self.alive or self.connections:
-                self.notify()
-
-                if (self.alive and
-                        pid == os.getpid() and self.ppid != os.getppid()):
-                    self.log.info("Parent changed, shutting down: %s", self)
-                    self.alive = False
-
-                # stop accepting requests
-                if not self.alive:
-                    if self.servers:
-                        self.log.info(
-                            "Stopping server: %s, connections: %s",
-                            pid, len(self.connections))
-                        for server in self.servers:
-                            server.close()
-                        self.servers.clear()
-
-                    # prepare connections for closing
-                    for conn in self.connections.values():
-                        if hasattr(conn, 'closing'):
-                            conn.closing()
-
-                yield from asyncio.sleep(1.0, loop=self.loop)
-        except KeyboardInterrupt:
-            pass
-
-        if self.servers:
-            for server in self.servers:
-                server.close()
-
-        yield from self.close()
-
-    @asyncio.coroutine
-    def _create_server(self, factory, sock):
-        return self.loop.create_server(factory, sock=sock.sock,
-                                       ssl=self.ssl_context)
-
-    @staticmethod
-    def _create_ssl_context(cfg):
-        """ Creates SSLContext instance for usage in asyncio.create_server.
-
-        See ssl.SSLSocket.__init__ for more details.
-        """
-        ctx = ssl.SSLContext(cfg.ssl_version)
-        ctx.load_cert_chain(cfg.certfile, cfg.keyfile)
-        ctx.verify_mode = cfg.cert_reqs
-        if cfg.ca_certs:
-            ctx.load_verify_locations(cfg.ca_certs)
-        if cfg.ciphers:
-            ctx.set_ciphers(cfg.ciphers)
-        return ctx
-
-
-class _wrp:
-
-    def __init__(self, proto, meth, tracking, add=True):
-        self._proto = proto
-        self._id = id(proto)
-        self._meth = meth
-        self._tracking = tracking
-        self._add = add
-
-    def __call__(self, *args):
-        if self._add:
-            self._tracking[self._id] = self._proto
-        elif self._id in self._tracking:
-            del self._tracking[self._id]
-
-        conn = self._meth(*args)
-        return conn
diff -rupN gunicorn-19.4.5-orig/gunicorn/workers/gaiohttp.py gunicorn-19.4.5/gunicorn/workers/gaiohttp.py
--- gunicorn-19.4.5-orig/gunicorn/workers/gaiohttp.py	2015-12-24 03:45:30.000000000 -0500
+++ gunicorn-19.4.5/gunicorn/workers/gaiohttp.py	1969-12-31 19:00:00.000000000 -0500
@@ -1,17 +0,0 @@
-# -*- coding: utf-8 -
-#
-# This file is part of gunicorn released under the MIT license.
-# See the NOTICE for more information.
-
-import sys
-
-if sys.version_info >= (3, 3):
-    try:
-        import aiohttp  # NOQA
-    except ImportError:
-        raise RuntimeError("You need aiohttp installed to use this worker.")
-    else:
-        from gunicorn.workers._gaiohttp import AiohttpWorker
-        __all__ = ['AiohttpWorker']
-else:
-    raise RuntimeError("You need Python >= 3.3 to use the asyncio worker")
diff -rupN gunicorn-19.4.5-orig/gunicorn.egg-info/SOURCES.txt gunicorn-19.4.5/gunicorn.egg-info/SOURCES.txt
--- gunicorn-19.4.5-orig/gunicorn.egg-info/SOURCES.txt	2016-01-04 19:11:58.000000000 -0500
+++ gunicorn-19.4.5/gunicorn.egg-info/SOURCES.txt	2016-03-01 12:19:10.000000000 -0500
@@ -208,10 +208,8 @@ gunicorn/management/__init__.py
 gunicorn/management/commands/__init__.py
 gunicorn/management/commands/run_gunicorn.py
 gunicorn/workers/__init__.py
-gunicorn/workers/_gaiohttp.py
 gunicorn/workers/async.py
 gunicorn/workers/base.py
-gunicorn/workers/gaiohttp.py
 gunicorn/workers/geventlet.py
 gunicorn/workers/ggevent.py
 gunicorn/workers/gthread.py
@@ -222,7 +220,6 @@ tests/support.py
 tests/t.py
 tests/test_arbiter.py
 tests/test_config.py
-tests/test_gaiohttp.py
 tests/test_http.py
 tests/test_invalid_requests.py
 tests/test_logger.py
@@ -324,4 +321,4 @@ tests/requests/valid/099.py
 tests/requests/valid/pp_01.http
 tests/requests/valid/pp_01.py
 tests/requests/valid/pp_02.http
-tests/requests/valid/pp_02.py
\ No newline at end of file
+tests/requests/valid/pp_02.py
diff -rupN gunicorn-19.4.5-orig/tests/test_gaiohttp.py gunicorn-19.4.5/tests/test_gaiohttp.py
--- gunicorn-19.4.5-orig/tests/test_gaiohttp.py	2015-12-31 08:40:51.000000000 -0500
+++ gunicorn-19.4.5/tests/test_gaiohttp.py	1969-12-31 19:00:00.000000000 -0500
@@ -1,194 +0,0 @@
-# -*- coding: utf-8 -
-#
-# This file is part of gunicorn released under the MIT license.
-# See the NOTICE for more information.
-
-import unittest
-import pytest
-aiohttp = pytest.importorskip("aiohttp")
-
-
-from aiohttp.wsgi import WSGIServerHttpProtocol
-
-import asyncio
-from gunicorn.workers import gaiohttp
-from gunicorn.workers._gaiohttp import _wrp
-from gunicorn.config import Config
-from unittest import mock
-
-
-class WorkerTests(unittest.TestCase):
-
-    def setUp(self):
-        self.loop = asyncio.new_event_loop()
-        asyncio.set_event_loop(None)
-        self.worker = gaiohttp.AiohttpWorker('age',
-                                             'ppid',
-                                             'sockets',
-                                             'app',
-                                             'timeout',
-                                             Config(),
-                                             'log')
-
-    def tearDown(self):
-        self.loop.close()
-
-    @mock.patch('gunicorn.workers._gaiohttp.asyncio')
-    def test_init_process(self, m_asyncio):
-        try:
-            self.worker.init_process()
-        except TypeError:
-            # to mask incomplete initialization of AiohttWorker instance:
-            # we pass invalid values for ctor args
-            pass
-
-        self.assertTrue(m_asyncio.get_event_loop.return_value.close.called)
-        self.assertTrue(m_asyncio.new_event_loop.called)
-        self.assertTrue(m_asyncio.set_event_loop.called)
-
-    @mock.patch('gunicorn.workers._gaiohttp.asyncio')
-    def test_run(self, m_asyncio):
-        self.worker.loop = mock.Mock()
-        self.worker.run()
-
-        self.assertTrue(m_asyncio.async.called)
-        self.assertTrue(self.worker.loop.run_until_complete.called)
-        self.assertTrue(self.worker.loop.close.called)
-
-    def test_factory(self):
-        self.worker.wsgi = mock.Mock()
-        self.worker.loop = mock.Mock()
-        self.worker.log = mock.Mock()
-        self.worker.cfg = Config()
-
-        f = self.worker.factory(
-            self.worker.wsgi, ('localhost', 8080))
-        self.assertIsInstance(f, WSGIServerHttpProtocol)
-
-    @mock.patch('gunicorn.workers._gaiohttp.asyncio')
-    def test__run(self, m_asyncio):
-        self.worker.ppid = 1
-        self.worker.alive = True
-        self.worker.servers = []
-        sock = mock.Mock()
-        sock.cfg_addr = ('localhost', 8080)
-        self.worker.sockets = [sock]
-        self.worker.wsgi = mock.Mock()
-        self.worker.log = mock.Mock()
-        self.worker.notify = mock.Mock()
-        loop = self.worker.loop = mock.Mock()
-        loop.create_server.return_value = asyncio.Future(loop=self.loop)
-        loop.create_server.return_value.set_result(sock)
-
-        self.loop.run_until_complete(self.worker._run())
-
-        self.assertTrue(self.worker.log.info.called)
-        self.assertTrue(self.worker.notify.called)
-
-    @mock.patch('gunicorn.workers._gaiohttp.asyncio')
-    def test__run_unix_socket(self, m_asyncio):
-        self.worker.ppid = 1
-        self.worker.alive = True
-        self.worker.servers = []
-        sock = mock.Mock()
-        sock.cfg_addr = '/tmp/gunicorn.sock'
-        self.worker.sockets = [sock]
-        self.worker.wsgi = mock.Mock()
-        self.worker.log = mock.Mock()
-        self.worker.notify = mock.Mock()
-        loop = self.worker.loop = mock.Mock()
-        loop.create_server.return_value = asyncio.Future(loop=self.loop)
-        loop.create_server.return_value.set_result(sock)
-
-        self.loop.run_until_complete(self.worker._run())
-
-        self.assertTrue(self.worker.log.info.called)
-        self.assertTrue(self.worker.notify.called)
-
-    def test__run_connections(self):
-        conn = mock.Mock()
-        self.worker.ppid = 1
-        self.worker.alive = False
-        self.worker.servers = [mock.Mock()]
-        self.worker.connections = {1: conn}
-        self.worker.sockets = []
-        self.worker.wsgi = mock.Mock()
-        self.worker.log = mock.Mock()
-        self.worker.loop = self.loop
-        self.worker.loop.create_server = mock.Mock()
-        self.worker.notify = mock.Mock()
-
-        def _close_conns():
-            self.worker.connections = {}
-
-        self.loop.call_later(0.1, _close_conns)
-        self.loop.run_until_complete(self.worker._run())
-
-        self.assertTrue(self.worker.log.info.called)
-        self.assertTrue(self.worker.notify.called)
-        self.assertFalse(self.worker.servers)
-        self.assertTrue(conn.closing.called)
-
-    @mock.patch('gunicorn.workers._gaiohttp.os')
-    @mock.patch('gunicorn.workers._gaiohttp.asyncio.sleep')
-    def test__run_exc(self, m_sleep, m_os):
-        m_os.getpid.return_value = 1
-        m_os.getppid.return_value = 1
-
-        self.worker.servers = [mock.Mock()]
-        self.worker.ppid = 1
-        self.worker.alive = True
-        self.worker.sockets = []
-        self.worker.log = mock.Mock()
-        self.worker.loop = mock.Mock()
-        self.worker.notify = mock.Mock()
-
-        slp = asyncio.Future(loop=self.loop)
-        slp.set_exception(KeyboardInterrupt)
-        m_sleep.return_value = slp
-
-        self.loop.run_until_complete(self.worker._run())
-        self.assertTrue(m_sleep.called)
-        self.assertTrue(self.worker.servers[0].close.called)
-
-    def test_close_wsgi_app(self):
-        self.worker.ppid = 1
-        self.worker.alive = False
-        self.worker.servers = [mock.Mock()]
-        self.worker.connections = {}
-        self.worker.sockets = []
-        self.worker.log = mock.Mock()
-        self.worker.loop = self.loop
-        self.worker.loop.create_server = mock.Mock()
-        self.worker.notify = mock.Mock()
-
-        self.worker.wsgi = mock.Mock()
-        self.worker.wsgi.close.return_value = asyncio.Future(loop=self.loop)
-        self.worker.wsgi.close.return_value.set_result(1)
-
-        self.loop.run_until_complete(self.worker._run())
-        self.assertTrue(self.worker.wsgi.close.called)
-
-        self.worker.wsgi = mock.Mock()
-        self.worker.wsgi.close.return_value = asyncio.Future(loop=self.loop)
-        self.worker.wsgi.close.return_value.set_exception(ValueError())
-
-        self.loop.run_until_complete(self.worker._run())
-        self.assertTrue(self.worker.wsgi.close.called)
-
-    def test_wrp(self):
-        conn = object()
-        tracking = {}
-        meth = mock.Mock()
-        wrp = _wrp(conn, meth, tracking)
-        wrp()
-
-        self.assertIn(id(conn), tracking)
-        self.assertTrue(meth.called)
-
-        meth = mock.Mock()
-        wrp = _wrp(conn, meth, tracking, False)
-        wrp()
-
-        self.assertNotIn(1, tracking)
-        self.assertTrue(meth.called)
